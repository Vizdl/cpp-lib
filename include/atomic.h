
/*
关于
volatile的本意是“易变的” 因为访问寄存器要比访问内存单元快的多,所以编译器一般都会作减少存取内存的优化，但有可能会读脏数据。
当要求使用volatile声明变量值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。
精确地说就是,遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问；
如果不使用valatile，则编译器将对所声明的语句进行优化。

与 register 相反。
*/

/*
内嵌汇编语法如下 :
       __asm__(汇编语句模板: 输出部分: 输入部分: 破坏描述部分)
共四个部分：汇编语句模板，输出部分，输入部分，破坏描述部分，各部分使用":"格开，汇编语句模板必不可少，其他三部分可选，'
如果使用了后面的部分，而前面部分为空，也需要用":"格开，相应部分内容为空。
例如：
             __asm__ __volatile__("cli": : :"memory")
*/
int add (int * pval, int num){
    int old;
    __asm__  volatile( // volatile : 修饰内嵌汇编时表示不要优化指令
        "lock; xaddl %2,%1;" // %1 += %2
        : "=a" (old) // =表示是输出参数,a表示rax寄存器
        : "m" (*pval) , "a"(num) // m 表示内存变量, a表示rax寄存器
        : "cc", "memory"
    );
    return old;
}